#include "uart1.h" 
#include "delay.h" 
/*--------------------------------------------------------------*/
/* --- -----------------实验内容 -------------------------------*/
/* --- 1-了解STC-ISP工具生产延时函数方法 -----------------------*/
/* --- 2-掌握子函数的创建与调用---------------------------------*/
/* --- 实验平台：未来电子STC32核心板----------------------------*/
/* --- 视频学习：https://space.bilibili.com/494969171 ----------*/
/* --- QQ交流群：702805632 -------------------------------------*/
/* --- 参考资料：STC32实验室参考例程 ---------------------------*/
/*--------------------------------------------------------------*/

bit B_TX1_Busy; //发送忙标志

/***************************************************************************
 * 描  述 : 串口1初始化函数
 * 入  参 : 无
 * 返回值 : 无
备注：波特率9600bps   晶振24MHz
 **************************************************************************/
void Uart1_Init(void)
{	 
	P3M1 &= 0xFC;	P3M0 &= 0xFC;	                  //设置P3.0 ,P3.1为准双向口  
	
	PCON &= 0x3f;		//波特率不倍速，串行口工作方式由SM0、SM1决定
	SCON = 0x50;		//8位数据,可变波特率，启动串行接收器
	AUXR |= 0x40;		//定时器1时钟为Fosc,即1T
	AUXR &= 0xfe;		//串口1选择定时器1为波特率发生器
	TMOD &= 0x0f;		//清除定时器1模式位
	TMOD |= 0x20;		//设定定时器1为8位自动重装方式
	TL1 = 0xB2;		  //设定定时初值
	TH1 = 0xB2;		  //设定定时器重装值
	ET1 = 0;		    //禁止定时器1中断
	TR1 = 1;		    //启动定时器1
	ES = 1;         // 串口1中断打开 
 	
 	EA = 1;               //总中断打开 
	
	delay_ms(100);
}

/***************************************************************************
 * 描  述 : 串口1发送数据函数
 * 入  参 : uint8 数据
 * 返回值 : 无
 **************************************************************************/
void SendDataByUart1(unsigned char dat)
{
    SBUF = dat;                 //写数据到UART数据寄存器
    B_TX1_Busy = 1;
    while(B_TX1_Busy);                   //清除TI位（该位必须软件清零）
} 
/***************************************************************************
 * 描  述 : 串口1中断服务函数
 * 入  参 : 无
 * 返回值 : 无
 **************************************************************************/
void Uart1() interrupt 4 using 1
{
	  ES = 0;  	                  // 串口1中断关闭
	  if (RI)                     //串行接收到停止位的中间时刻时，该位置1
   {
      RI = 0;                 //清除RI位 （该位必须软件清零）SBUF; 
		  program_automatic_update();	      
   }
   if (TI)                    //在停止位开始发送时，该位置1
   {
      TI = 0;                 //清除TI位（该位必须软件清零） 
		  B_TX1_Busy = 0;
   }
	 ES =  1;                   // 串口1中断打开
}
//========================================================================
// 函数: void PrintString1(u8 *puts)
// 描述: 串口1发送字符串函数。
// 参数: puts:  字符串指针.
// 返回: none.
// 版本: VER1.0
// 日期: 2022-09-24
// 备注: 
//========================================================================
void PrintString1(unsigned char *puts)
{
    for (; *puts != 0;  puts++)     //遇到停止符0结束
    {
        SBUF = *puts;
        B_TX1_Busy = 1;
        while(B_TX1_Busy);
    }
}
//========================================================================
// 函数: void program_automatic_update(void)
// 描述: 程序自动下载。
// 参数: 程序自动下载。.
// 返回: none.
// 版本: VER1.0
// 日期: 2022-09-24
// 备注: 
//======================================================================== 

void program_automatic_update(void)
{
    static unsigned char recv_cnt = 0;
    if (SBUF == 0xAF)
    {
        if (++recv_cnt >= 5)
        {
            recv_cnt = 0;
            IAP_CONTR = 0x60;   //触发软件复位，从ISP开始执行
        }
    }
    else
    {
        recv_cnt = 0;
    }
}
 /**************************************************************************
功能描述：串口打印数据
入口参数：无
返回值：无 1236
 *************************************************************************/ 
void Uart_Send_ADC_data(unsigned int  ADC_DATA)
{
	  unsigned char temp=0,temp1=0,temp2=0,temp3=0;
	
	     temp=(ADC_DATA/1000)+'0'; 
	     temp1=(ADC_DATA/100%10)+'0'; 
	     temp2=(ADC_DATA/10%10)+'0';
	     temp3=(ADC_DATA%10)+'0';

	  	 PrintString1("SR04:");
			 SendDataByUart1(temp);
			 SendDataByUart1(temp1 );
			 SendDataByUart1(temp2);
			 SendDataByUart1(temp3); 		
		   PrintString1(" CM\r\n");			
}












